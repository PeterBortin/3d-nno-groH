<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PVO Simulation with Roads, Cars, and Drone Effects</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
  #score {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-family: monospace;
    font-size: 24px;
    background: rgba(0,0,0,0.5);
    padding: 4px 12px;
    border-radius: 8px;
    text-align: center;
  }
  .drone-toolbar {
    position: absolute;
    color: white;
    font-family: monospace;
    font-size: 20px;
    background: rgba(0,0,0,0.7);
    padding: 2px 6px;
    border-radius: 6px;
    pointer-events: none;
  }
  #control-panel {
    position: absolute;
    top: 50px;
    left: 10px;
    color: white;
    font-family: monospace;
    font-size: 14px;
    background: rgba(0,0,0,0.7);
    padding: 10px;
    border-radius: 8px;
    pointer-events: auto;
  }
  #control-panel label {
    display: block;
    margin: 5px 0;
  }
  #control-panel input[type="number"] {
    width: 60px;
    background: #333;
    color: white;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 2px;
    font-family: monospace;
  }
  #control-panel button {
    background: #555;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
    font-family: monospace;
    margin-top: 10px;
  }
  #control-panel button:hover {
    background: #777;
  }
</style>
</head>
<body>
<div id="score">Знищено: 000</div>
<div id="control-panel">
  <label>Герань -3: <input type="number" id="red-drones" value="2" min="0" max="10"></label>
  <label>Герань -2: <input type="number" id="white-drones" value="5" min="0" max="20"></label>
  <label>Балістика: <input type="number" id="missile-interval" value="16" min="2" max="60"></label>
  <button onclick="applySettings()">Застосувати</button>
</div>
<canvas id="canvas"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// === Scene setup ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(64, window.innerWidth/window.innerHeight, 0.1, 1000);
let camPolar = Math.PI/4;
let camAzim = 0;
const camRadius = 20;
camera.position.set(0,6,16);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({canvas: document.getElementById("canvas")});
renderer.setSize(window.innerWidth, window.innerHeight);

// === Grid ===
const gridHelper = new THREE.GridHelper(20, 20, 0xffffff, 0x444444);
scene.add(gridHelper);

// === Roads ===
const roads = [];
function createRoad(x, z, w, h){
  const roadGeometry = new THREE.PlaneGeometry(w,h);
  const roadMaterial = new THREE.MeshBasicMaterial({color:0x222222, side:THREE.DoubleSide});
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI/2;
  road.position.set(x,0.005,z);
  scene.add(road);
  roads.push({mesh:road, w, h, x, z});
}

// Основные дороги
createRoad(0, 0, 20, 1.5);
createRoad(0, 0, 1.5, 20);
// Дополнительные дороги
createRoad(0, 5, 20, 1);
createRoad(0, -5, 20, 1);
createRoad(5, 0, 1, 20);
createRoad(-5, 0, 1, 20);

// === Radar Gradient ===
const radarSize = 512;
const radarCanvas = document.createElement('canvas');
radarCanvas.width = radarSize;
radarCanvas.height = radarSize;
const radarCtx = radarCanvas.getContext('2d');

function drawRadarGradient(){
  radarCtx.clearRect(0,0,radarSize,radarSize);
  if(radarCtx.createConicGradient){
    const grad = radarCtx.createConicGradient(Math.PI, radarSize/2, radarSize/2);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(0.4, 'rgba(9,20,0,0.05)');
    grad.addColorStop(1, '#70FF00');
    radarCtx.fillStyle = grad;
  } else {
    const grad = radarCtx.createRadialGradient(radarSize/2, radarSize/2, 0, radarSize/2, radarSize/2, radarSize/2);
    grad.addColorStop(0, 'rgba(0,255,0,0.4)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    radarCtx.fillStyle = grad;
  }
  radarCtx.fillRect(0,0,radarSize,radarSize);
}
drawRadarGradient();

const radarTexture = new THREE.CanvasTexture(radarCanvas);
radarTexture.rotation = 0;
radarTexture.center.set(0.5,0.5);

const radarGeometry = new THREE.CircleGeometry(10,64);
const radarMaterial = new THREE.MeshBasicMaterial({map: radarTexture, transparent:true, opacity:0.25, side:THREE.DoubleSide});
const radar = new THREE.Mesh(radarGeometry,radarMaterial);
radar.rotation.x = -Math.PI/2;
radar.position.y = 0.01;
scene.add(radar);

function animateRadar(){radarTexture.rotation -= 0.01;}

// === PVO ===
const pvoGeometry = new THREE.SphereGeometry(0.5,16,16,0,Math.PI*2,0,Math.PI/2);
const pvoMaterial = new THREE.MeshBasicMaterial({color:0x00ff00});
const pvo = new THREE.Mesh(pvoGeometry,pvoMaterial);
pvo.position.set(0,0.25,0);
scene.add(pvo);

// === Houses ===
let houses = [];
function spawnHouses(count=64){
  houses = [];
  let attempts = 0;
  while(houses.length < count && attempts < count*10){
    attempts++;
    const w = Math.random()*0.8+0.5;
    const h = Math.random()*2+0.5;
    const d = Math.random()*0.8+0.5;
    const x = (Math.random()-0.5)*16;
    const z = (Math.random()-0.5)*16;

    let onRoad = false;
    for(const road of roads){
      if(Math.abs(x-road.x)<road.w/2 + w/2 && Math.abs(z-road.z)<road.h/2 + d/2){
        onRoad = true;
        break;
      }
    }
    if(onRoad) continue;

    const houseGeometry = new THREE.BoxGeometry(w,h,d);
    const houseMaterial = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.5});
    const house = new THREE.Mesh(houseGeometry,houseMaterial);
    house.position.set(x,h/2,z);
    scene.add(house);
    houses.push(house);
    house.userData = {isFlashing:false, flashInterval:null};
  }
}
spawnHouses();

// === Drones ===
const drones = [];
const droneTrails = [];
function createDrone(type="white"){
  const color = type==="red"?0xff0000:0xffffff;
  const drone = new THREE.Mesh(new THREE.SphereGeometry(0.1,12,12), new THREE.MeshBasicMaterial({color}));
  
  let targetHouse = null;
  if(type==="red" && houses.length>0){
    targetHouse = houses[Math.floor(Math.random()*houses.length)];
    if(targetHouse.userData.flashInterval===null){
      targetHouse.userData.isFlashing = true;
      targetHouse.userData.flashInterval = setInterval(()=>{
        targetHouse.material.color.set(targetHouse.material.color.getHex()===0xffa500?0xffffff:0xffa500);
      },200);
    }
  }
  
  const startX = (Math.random()-0.5)*20;
  const startZ = (Math.random()-0.5)*20;
  const startY = 6 + Math.random()*8;
  drone.position.set(startX,startY,startZ);
  
  let dir;
  if(targetHouse){
    dir = new THREE.Vector3().subVectors(targetHouse.position,drone.position).normalize();
  } else {
    const destX = (Math.random()-0.5)*20;
    const destZ = (Math.random()-0.5)*20;
    const destY = 6 + Math.random()*4;
    const destination = new THREE.Vector3(destX,destY,destZ);
    dir = new THREE.Vector3().subVectors(destination,drone.position).normalize();
  }

  const baseSpeed = type==="red" ? 0.015 + Math.random()*0.015 : 0.0025 + Math.random()*0.005;
  const diveSpeed = 0.015 + Math.random()*0.03;

  const toolbar = document.createElement('div');
  toolbar.className = 'drone-toolbar';
  document.body.appendChild(toolbar);

  const trajectoryColor = type==="red" ? 0xff0000 : 0xffffff;
  const futureTrajectoryGeometry = new THREE.BufferGeometry();
  const futureTrajectoryMaterial = new THREE.LineDashedMaterial({
    color: trajectoryColor,
    linewidth: 1,
    scale: 1,
    dashSize: 0.2,
    gapSize: 0.2,
    transparent: true,
    opacity: 0.5
  });
  const futureTrajectoryLine = new THREE.Line(futureTrajectoryGeometry, futureTrajectoryMaterial);
  scene.add(futureTrajectoryLine);

  drone.userData = {
    target: targetHouse,
    direction: dir,
    speed: baseSpeed,
    baseSpeed,
    diveSpeed,
    hasAttacked: false,
    type,
    trail: [],
    diving: false,
    futureTrajectoryLine,
    toolbar
  };
  scene.add(drone);
  drones.push(drone);
}

// === Scene Parameters ===
let targetRedDrones = 2;
let targetWhiteDrones = 5;
let missileInterval = 16000;

// Initialize drones
for(let i=0;i<targetWhiteDrones;i++){createDrone("white");}
for(let i=0;i<targetRedDrones;i++){createDrone("red");}

// Apply settings from control panel
function applySettings(){
  targetRedDrones = parseInt(document.getElementById("red-drones").value) || 2;
  targetWhiteDrones = parseInt(document.getElementById("white-drones").value) || 5;
  missileInterval = (parseInt(document.getElementById("missile-interval").value) || 16) * 1000;
}

// === Missiles ===
const missiles = [];
let lastMissileTime = Date.now();
function createMissile() {
  const missile = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.5, 12), new THREE.MeshBasicMaterial({color: 0xff0000}));
  const x = (Math.random() - 0.5) * 20;
  const z = (Math.random() - 0.5) * 20;
  const startY = 8;
  missile.position.set(x, startY, z);
  missile.userData = {speed: 0.2, trail: []};
  scene.add(missile);
  missiles.push(missile);
}

// === Rockets ===
const rockets = [];
function launchRocket(target){
  if(!target) return;
  const rocket = new THREE.Mesh(new THREE.SphereGeometry(0.1,8,8), new THREE.MeshBasicMaterial({color:0xffff00}));
  rocket.position.copy(pvo.position);
  rocket.userData = {
    target,
    trail: [],
    initialDistance: rocket.position.distanceTo(target.position)
  };
  scene.add(rocket);
  rockets.push(rocket);
}

// === Explosion ===
function createExplosion(position, scaleFactor=1, isMissile=false){
  const geometry = isMissile ? new THREE.SphereGeometry(0.1,16,16,0,Math.PI*2,0,Math.PI/2) : new THREE.SphereGeometry(0.1,16,16);
  const explosion = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color:0xffaa00, transparent:true, opacity:0.9}));
  explosion.position.copy(position);
  if(isMissile) explosion.position.y = 0.01;
  scene.add(explosion);
  
  let scale = 0.1 * scaleFactor;
  const interval = setInterval(()=>{
    scale += 0.4 * scaleFactor;
    explosion.scale.setScalar(scale);
    explosion.material.opacity -= 0.05;
    if(explosion.material.opacity <=0){
      scene.remove(explosion);
      clearInterval(interval);
    }
  },50);
}

// === House Marker ===
function createHouseMarker(house, isMissileHit = false){
  const geometry = new THREE.EdgesGeometry(house.geometry);
  const material = new THREE.LineDashedMaterial({
    color: 0xffa500,
    linewidth: 1,
    scale: 2,
    dashSize: isMissileHit ? 0.2 : 0,
    gapSize: isMissileHit ? 0.2 : 0
  });
  const line = new THREE.LineSegments(geometry, material);
  if (isMissileHit) {
    line.computeLineDistances();
  }
  line.position.copy(house.position);
  scene.add(line);
}

// === Drone and Rocket Trail ===
function addTrail(object, isMissile=false, isRocket=false){
  const trailGeo = new THREE.SphereGeometry(isRocket ? 0.08 : 0.05, 6, 6);
  const trailColor = isRocket ? 0xffff00 : (isMissile ? 0xffff00 : 0xff5500);
  const trailMat = new THREE.MeshBasicMaterial({
    color: trailColor,
    transparent: true,
    opacity: isRocket ? 0.4 : 0.6
  });
  const particle = new THREE.Mesh(trailGeo, trailMat);
  particle.position.copy(object.position);
  scene.add(particle);
  object.userData.trail.push({mesh: particle, life: isRocket ? 60 : 20});
  droneTrails.push(object.userData.trail[object.userData.trail.length-1]);
}

// === Score ===
let score = 0;
function updateScore(){document.getElementById("score").innerText = `SCORE: ${String(score).padStart(3,'0')}`;}

// === Controls ===
let isDragging = false;
let isPotentialDrag = false;
let startX = 0;
let startY = 0;
let previousMousePosition = {x:0,y:0};
function rotateScene(deltaX,deltaY){
  camAzim -= deltaX; 
  camPolar += deltaY;
  if(camPolar<0.1) camPolar = 0.1;
  if(camPolar>Math.PI/2) camPolar = Math.PI/2;
  camera.position.x = camRadius * Math.sin(camPolar) * Math.sin(camAzim);
  camera.position.y = camRadius * Math.cos(camPolar);
  camera.position.z = camRadius * Math.sin(camPolar) * Math.cos(camAzim);
  camera.lookAt(0,0,0);
}
function onPointerDown(event){
  if(event.touches && event.touches.length === 1){
    isPotentialDrag = true;
    startX = event.touches[0].clientX;
    startY = event.touches[0].clientY;
    previousMousePosition.x = startX;
    previousMousePosition.y = startY;
  } else {
    if(event.button === 0){
      isDragging = true;
      previousMousePosition.x = event.clientX;
      previousMousePosition.y = event.clientY;
    } else if(event.button === 2){ 
      const threats = [...drones, ...missiles];
      if(threats.length > 0){
        let target = threats[Math.floor(Math.random() * threats.length)];
        launchRocket(target);
      }
    }
  }
}
function onPointerMove(event){
  let clientX, clientY;
  if(event.touches && event.touches.length === 1){
    clientX = event.touches[0].clientX;
    clientY = event.touches[0].clientY;
  } else {
    clientX = event.clientX;
    clientY = event.clientY;
  }
  const deltaX = Math.abs(clientX - startX);
  const deltaY = Math.abs(clientY - startY);
  if(isPotentialDrag && (deltaX > 10 || deltaY > 10)){
    isDragging = true;
    isPotentialDrag = false;
  }
  if(isDragging){
    rotateScene((clientX - previousMousePosition.x) * 0.01, (clientY - previousMousePosition.y) * 0.01);
    previousMousePosition.x = clientX;
    previousMousePosition.y = clientY;
  }
}
function onPointerUp(event){
  if(isPotentialDrag){
    const threats = [...drones, ...missiles];
    if(threats.length > 0){
      let target = threats[Math.floor(Math.random() * threats.length)];
      launchRocket(target);
    }
  }
  isPotentialDrag = false;
  isDragging = false;
}
document.addEventListener("mousedown",onPointerDown);
document.addEventListener("mousemove",onPointerMove);
document.addEventListener("mouseup",onPointerUp);
document.addEventListener("touchstart",onPointerDown);
document.addEventListener("touchmove",onPointerMove);
document.addEventListener("touchend",onPointerUp);
document.addEventListener("contextmenu",(e)=>e.preventDefault());

// === Cars ===
const cars = [];
function spawnCars(){
  roads.forEach(road=>{
    const isHorizontal = road.w > road.h;
    const numCars = 2;
    for(let i=0;i<numCars;i++){
      const car = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.4), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.5}));
      const speed = 0.01 + Math.random()*0.02;
      if(isHorizontal){
        const startX = road.x - road.w/2 + Math.random()*road.w;
        car.position.set(startX,0.1,road.z);
        car.userData = {speed, baseSpeed: speed, isHorizontal:true, road};
      } else {
        const startZ = road.z - road.h/2 + Math.random()*road.h;
        car.position.set(road.x,0.1,startZ);
        car.userData = {speed, baseSpeed: speed, isHorizontal:false, road};
      }
      scene.add(car);
      cars.push(car);
    }
  });
}
spawnCars();

// === Cars Update (stop&go) ===
function updateCars(){
  const safeDistance = 1.0;
  const accel = 0.0005;
  const brake = 0.001;

  cars.forEach(car=>{
    const data = car.userData;
    let nearestDist = Infinity;

    cars.forEach(other=>{
      if(other === car) return;
      const oData = other.userData;
      if(oData.isHorizontal !== data.isHorizontal) return;
      if(oData.road !== data.road) return;

      if(data.isHorizontal){
        if(other.position.x > car.position.x){
          const dist = other.position.x - car.position.x;
          if(dist < nearestDist) nearestDist = dist;
        }
      } else {
        if(other.position.z > car.position.z){
          const dist = other.position.z - car.position.z;
          if(dist < nearestDist) nearestDist = dist;
        }
      }
    });

    if(nearestDist < safeDistance){
      data.speed = Math.max(0, data.speed - brake);
    } else if(data.speed < data.baseSpeed){
      data.speed = Math.min(data.baseSpeed, data.speed + accel);
    }

    if(data.isHorizontal){
      car.position.x += data.speed;
      if(car.position.x > data.road.x + data.road.w / 2) car.position.x = data.road.x - data.road.w / 2;
    } else {
      car.position.z += data.speed;
      if(car.position.z > data.road.z + data.road.h / 2) car.position.z = data.road.z - data.road.h / 2;
    }
  });
}

// === Animate ===
function animate(){
  requestAnimationFrame(animate);
  updateCars();
  animateRadar();

  // Spawn missile based on missileInterval
  if(Date.now() - lastMissileTime > missileInterval){
    createMissile();
    lastMissileTime = Date.now();
  }

  // Update drone toolbars
  drones.forEach(drone => {
    const altitude = Math.round(drone.position.y * 100);
    drone.userData.toolbar.textContent = `${altitude}m`;
    
    const vector = drone.position.clone().project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
    
    drone.userData.toolbar.style.left = `${x}px`;
    drone.userData.toolbar.style.top = `${y - 20}px`;
  });

  // Drones
  for(let i=drones.length-1;i>=0;i--){
    const drone=drones[i];
    const data=drone.userData;

    // Update future trajectory
    const futurePoints = [];
    let currentPos = drone.position.clone();
    const futureSteps = 50;
    const stepDistance = data.speed * 20;
    const gridBoundary = 10;
    for(let j=0; j<futureSteps; j++){
      let nextPos = currentPos.clone().add(data.direction.clone().multiplyScalar(stepDistance));
      if(Math.abs(nextPos.x) > gridBoundary || Math.abs(nextPos.z) > gridBoundary || nextPos.y < 0) break;
      futurePoints.push(nextPos);
      currentPos = nextPos;
    }
    const futurePositions = new Float32Array(futurePoints.length * 3);
    for(let j=0; j<futurePoints.length; j++){
      futurePositions[j*3] = futurePoints[j].x;
      futurePositions[j*3+1] = futurePoints[j].y;
      futurePositions[j*3+2] = futurePoints[j].z;
    }
    data.futureTrajectoryLine.geometry.setAttribute('position', new THREE.BufferAttribute(futurePositions, 3));
    data.futureTrajectoryLine.computeLineDistances();

    if(data.type==="red" && data.target){
      const distXZ = Math.sqrt((drone.position.x - data.target.position.x)**2 + (drone.position.z - data.target.position.z)**2);
      if(distXZ < 5){
        data.diving = true;
        data.speed = data.diveSpeed;
      }
      if(data.diving) addTrail(drone);
    } else {
      addTrail(drone);
    }
    
    if(data.target && houses.includes(data.target)){
      const targetPos = data.target.position.clone();
      if(drone.position.distanceTo(targetPos)<5 && !data.hasAttacked){
        data.hasAttacked=true;
        data.speed=data.diveSpeed;
        targetPos.y=0;
      }
      const dir = targetPos.clone().sub(drone.position).normalize();
      drone.position.add(dir.multiplyScalar(data.speed));
      
      if(drone.position.distanceTo(targetPos)<0.1){
        createExplosion(drone.position);
        createHouseMarker(data.target, false);
        scene.remove(drone);
        document.body.removeChild(data.toolbar);
        drones.splice(i,1);
        scene.remove(data.futureTrajectoryLine);
        scene.remove(data.target);
        houses.splice(houses.indexOf(data.target),1);
        if(data.target.userData.flashInterval){clearInterval(data.target.userData.flashInterval);}
        score=Math.min(score+1,999);
        updateScore();
      }
    } else {
      drone.position.add(data.direction.clone().multiplyScalar(data.speed));
      if(drone.position.y <= 0 || Math.abs(drone.position.x)>16 || Math.abs(drone.position.z)>16){
        createExplosion(new THREE.Vector3(drone.position.x, Math.max(drone.position.y,0), drone.position.z));
        scene.remove(drone);
        document.body.removeChild(data.toolbar);
        drones.splice(i,1);
        scene.remove(data.futureTrajectoryLine);
      }
    }
  }

  // Missiles
  for(let i = missiles.length - 1; i >= 0; i--){
    const missile = missiles[i];
    missile.position.y -= missile.userData.speed;
    addTrail(missile, true);
    if(missile.position.y <= 0){
      createExplosion(missile.position, 10, true);
      scene.remove(missile);
      missiles.splice(i, 1);
      const blastRadius = 3;
      for(let j = houses.length - 1; j >= 0; j--){
        const house = houses[j];
        const dist = Math.sqrt((house.position.x - missile.position.x)**2 + (house.position.z - missile.position.z)**2);
        if(dist < blastRadius){
          createExplosion(house.position);
          createHouseMarker(house, true);
          scene.remove(house);
          houses.splice(j, 1);
          if(house.userData.flashInterval){clearInterval(house.userData.flashInterval);}
          score = Math.min(score + 1, 999);
          updateScore();
        }
      }
    }
  }

  // Update trails
  for(let i=droneTrails.length-1;i>=0;i--){
    const t = droneTrails[i];
    t.mesh.material.opacity -= 0.03;
    if(t.mesh.material.opacity <=0){
      scene.remove(t.mesh);
      droneTrails.splice(i,1);
    }
  }

  // Maintain drone counts
  let whiteCount = drones.filter(d=>d.userData.type==="white").length;
  let redCount = drones.filter(d=>d.userData.type==="red").length;
  if(whiteCount<targetWhiteDrones) createDrone("white");
  if(redCount<targetRedDrones) createDrone("red");

  // Prevent exceeding limits
  while(whiteCount > targetWhiteDrones){
    const drone = drones.find(d=>d.userData.type==="white");
    if(drone){
      scene.remove(drone);
      document.body.removeChild(drone.userData.toolbar);
      scene.remove(drone.userData.futureTrajectoryLine);
      drones.splice(drones.indexOf(drone),1);
      whiteCount--;
    }
  }
  while(redCount > targetRedDrones){
    const drone = drones.find(d=>d.userData.type==="red");
    if(drone){
      scene.remove(drone);
      document.body.removeChild(drone.userData.toolbar);
      scene.remove(drone.userData.futureTrajectoryLine);
      drones.splice(drones.indexOf(drone),1);
      redCount--;
    }
  }
  
  // Rockets
  for(let i=rockets.length-1;i>=0;i--){
    const rocket=rockets[i];
    if(!rocket.userData.target){
      scene.remove(rocket);
      rockets.splice(i,1);
      continue;
    }
    
    const distanceToTarget = rocket.position.distanceTo(rocket.userData.target.position);
    const remainingFraction = distanceToTarget / rocket.userData.initialDistance;
    
    let speed;
    if(remainingFraction > 0.8) {
      speed = 0.1;
    } else if(remainingFraction > 0.2) {
      speed = 1.0;
    } else {
      speed = 0.20;
    }

    const dir = rocket.userData.target.position.clone().sub(rocket.position).normalize();
    rocket.position.add(dir.multiplyScalar(speed));
    
    addTrail(rocket, false, true);

    if(distanceToTarget < 0.1){
      createExplosion(rocket.position);
      scene.remove(rocket);
      rockets.splice(i,1);
      const target=rocket.userData.target;
      if(drones.includes(target)){
        scene.remove(target);
        document.body.removeChild(target.userData.toolbar);
        drones.splice(drones.indexOf(target),1);
        scene.remove(target.userData.futureTrajectoryLine);
        score=Math.min(score+1,999);
        updateScore();
      } else if(missiles.includes(target)){
        scene.remove(target);
        missiles.splice(missiles.indexOf(target),1);
        score=Math.min(score+1,999);
        updateScore();
      }
    }
    if(Math.abs(rocket.position.x)>999||Math.abs(rocket.position.z)>999){
      scene.remove(rocket);
      rockets.splice(i,1);
    }
  }

  renderer.render(scene,camera);
}
animate();
updateScore();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
