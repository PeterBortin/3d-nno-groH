<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>nnoüá∫üá¶</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
  .drone-toolbar {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: white;
    font-family: monospace;
    font-size: 12px;
    background: rgba(0,0,0,0.7);
    padding: 2px 6px;
    border-radius: 4px;
    pointer-events: none;
  }
  #score-counter {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    font-family: monospace;
    font-size: 20px;
    background: rgba(0,0,0,0.5);
    padding: 5px 10px;
    border-radius: 4px;
  }
</style>
</head>
<body>
<div id="score-counter">0</div>
<canvas id="canvas"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// === Global Variables ===
let score = 0;
const GRID_SIZE = 20;

// === Scene setup ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(64, window.innerWidth/window.innerHeight, 0.1, 1000);
let camPolar = Math.PI/4;
let camAzim = 0;
const camRadius = 20;
camera.position.set(0,6,16);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({canvas: document.getElementById("canvas")});
renderer.setSize(window.innerWidth, window.innerHeight);

// === Grid ===
const gridHelper = new THREE.GridHelper(GRID_SIZE, 20, 0xffffff, 0x444444);
scene.add(gridHelper);

// === Roads ===
const roads = [];
function createRoad(x, z, w, h){
  const roadGeometry = new THREE.PlaneGeometry(w,h);
  const roadMaterial = new THREE.MeshBasicMaterial({color:0x222222, side:THREE.DoubleSide});
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI/2;
  road.position.set(x,0.005,z);
  road.userData = {isRoad: true}; // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–∫—É, —á—Ç–æ–±—ã –º–∞—Ä–∫–µ—Ä –±—ã–ª –≤—ã—à–µ
  scene.add(road);
  roads.push({mesh:road, w, h, x, z});
}

// –û—Å–Ω–æ–≤–Ω—ã–µ –¥–æ—Ä–æ–≥–∏
createRoad(0, 0, 20, 1.5);
createRoad(0, 0, 1.5, 20);
// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–æ—Ä–æ–≥–∏
createRoad(0, 5, 20, 1);
createRoad(0, -5, 20, 1);
createRoad(5, 0, 1, 20);
createRoad(-5, 0, 1, 20);
createRoad(0, 8, 20, 1);
createRoad(8, 0, 1, 20);

// === Radar Gradient ===
const radarSize = 512;
const radarCanvas = document.createElement('canvas');
radarCanvas.width = radarSize;
radarCanvas.height = radarSize;
const radarCtx = radarCanvas.getContext('2d');

function drawRadarGradient(){
  radarCtx.clearRect(0,0,radarSize,radarSize);
  if(radarCtx.createConicGradient){
    const grad = radarCtx.createConicGradient(Math.PI, radarSize/2, radarSize/2);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(0.4, 'rgba(9,20,0,0.05)');
    grad.addColorStop(1, '#70FF00');
    radarCtx.fillStyle = grad;
  } else {
    const grad = radarCtx.createRadialGradient(radarSize/2, radarSize/2, 0, radarSize/2, radarSize/2, radarSize/2);
    grad.addColorStop(0, 'rgba(0,255,0,0.4)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    radarCtx.fillStyle = grad;
  }
  radarCtx.fillRect(0,0,radarSize,radarSize);
}
drawRadarGradient();

const radarTexture = new THREE.CanvasTexture(radarCanvas);
radarTexture.rotation = 0;
radarTexture.center.set(0.5,0.5);

const radarGeometry = new THREE.CircleGeometry(10,64);
const radarMaterial = new THREE.MeshBasicMaterial({map: radarTexture, transparent:true, opacity:0.25, side:THREE.DoubleSide});
const radar = new THREE.Mesh(radarGeometry,radarMaterial);
radar.rotation.x = -Math.PI/2;
radar.position.y = 0.01;
scene.add(radar);

function animateRadar(){radarTexture.rotation -= 0.01;}

// === PVO ===
const pvoGeometry = new THREE.SphereGeometry(0.5,16,16,0,Math.PI*2,0,Math.PI/2);
const pvoMaterial = new THREE.MeshBasicMaterial({color:0x00ff00});
const pvo = new THREE.Mesh(pvoGeometry,pvoMaterial);
pvo.position.set(0,0.25,0);
scene.add(pvo);

// === Houses ===
let houses = [];
function spawnHouses(count=120){
  houses = [];
  const gridSize = 10;
  const sectorSize = 20 / gridSize;
  const positions = [];
  const minSpacing = 1.2;

  for(let sx = 0; sx < gridSize; sx++){
    for(let sz = 0; sz < gridSize; sz++){
      positions.push({x: sx * sectorSize - 10 + sectorSize / 2, z: sz * sectorSize - 10 + sectorSize / 2});
    }
  }
  for(let i = positions.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [positions[i], positions[j]] = [positions[j], positions[i]];
  }

  let placed = 0;
  for(const pos of positions){
    if(placed >= count) break;
    const x = pos.x + (Math.random() - 0.5) * sectorSize * 0.5;
    const z = pos.z + (Math.random() - 0.5) * sectorSize * 0.5;
    
    const blocks = [];
    const numBlocks = Math.random() < 0.3 ? 3 : (Math.random() < 0.6 ? 2 : 1); 
    
    // –û—Å–Ω–æ–≤–Ω–æ–π –±–ª–æ–∫ (Main Block)
    const mainW = Math.random() * 0.8 + 0.8;
    const mainD = Math.random() * 0.8 + 0.8;
    const mainH = Math.random() * 1.5 + 1.0;
    blocks.push({w: mainW, d: mainD, h: mainH, dx: 0, dz: 0});

    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –±–ª–æ–∫–∏ (Wings)
    if (numBlocks >= 2) {
      const wingW = Math.random() * 0.6 + 0.6;
      const wingD = Math.random() * 0.6 + 0.6;
      const wingH = Math.random() * 1.0 + 0.5;
      const posIndex = Math.floor(Math.random() * 4);
      let dx = 0, dz = 0;
      if (posIndex === 0) dx = mainW / 2 + wingW / 2;
      else if (posIndex === 1) dx = -(mainW / 2 + wingW / 2);
      else if (posIndex === 2) dz = mainD / 2 + wingD / 2;
      else if (posIndex === 3) dz = -(mainD / 2 + wingD / 2);
      blocks.push({w: wingW, d: wingD, h: wingH, dx, dz});
    }

    if (numBlocks === 3) {
      const wing2W = Math.random() * 0.6 + 0.6;
      const wing2D = Math.random() * 0.6 + 0.6;
      const wing2H = Math.random() * 1.0 + 0.5;
      
      let dx2 = 0, dz2 = 0;
      let safePos = false;
      while (!safePos) {
        const posIndex2 = Math.floor(Math.random() * 4);
        const newDx = posIndex2 === 0 ? mainW / 2 + wing2W / 2 : (posIndex2 === 1 ? -(mainW / 2 + wing2W / 2) : 0);
        const newDz = posIndex2 === 2 ? mainD / 2 + wing2D / 2 : (posIndex2 === 3 ? -(mainD / 2 + wing2D / 2) : 0);
        
        if (Math.abs(newDx - blocks[1].dx) > (wing2W/2 + blocks[1].w/2) || Math.abs(newDz - blocks[1].dz) > (wing2D/2 + blocks[1].d/2)) {
            dx2 = newDx;
            dz2 = newDz;
            safePos = true;
        }
      }
      blocks.push({w: wing2W, d: wing2D, h: wing2H, dx: dx2, dz: dz2});
    }

    let onRoad = false;
    let maxHouseW = 0;
    let maxHouseD = 0;
    blocks.forEach(b => {
        maxHouseW = Math.max(maxHouseW, b.w);
        maxHouseD = Math.max(maxHouseD, b.d);
    });

    for(const road of roads){
      if(Math.abs(x-road.x)<road.w/2 + maxHouseW/2 && Math.abs(z-road.z)<road.h/2 + maxHouseD/2){
        onRoad = true;
        break;
      }
    }
    if(onRoad) continue;

    let tooClose = false;
    for(const house of houses){
      const dist = Math.sqrt((x - house.position.x)**2 + (z - house.position.z)**2);
      if(dist < minSpacing){
        tooClose = true;
        break;
      }
    }
    if(tooClose) continue;

    const houseGroup = new THREE.Group();
    houseGroup.position.set(x, 0, z);

    const houseMaterial = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.5});
    
    blocks.forEach(block => {
        const geometry = new THREE.BoxGeometry(block.w, block.h, block.d);
        const mesh = new THREE.Mesh(geometry, houseMaterial.clone());
        mesh.position.set(block.dx, block.h / 2, block.dz);
        houseGroup.add(mesh);
    });

    scene.add(houseGroup);
    houses.push(houseGroup);
    houseGroup.userData = {isFlashing:false, flashInterval:null, isHit:false};
    placed++;
  }
}
spawnHouses();

// === Drones ===
const DRONE_SIZE = 0.1; 
const drones = [];
const trails = [];
function createDrone(type="white"){
  let color;
  if(type === "red") color = 0xff0000;
  else if(type === "white") color = 0xffffff;
  else if(type === "scout") color = 0x0000ff;
  const drone = new THREE.Mesh(new THREE.SphereGeometry(DRONE_SIZE,12,12), new THREE.MeshBasicMaterial({color}));
  
  let targetHouse = null;
  if(type==="red" && houses.length>0){
    const availableHouses = houses.filter(h => !h.userData.isHit);
    if (availableHouses.length > 0) {
      targetHouse = availableHouses[Math.floor(Math.random()*availableHouses.length)];
      if(targetHouse.userData.flashInterval===null){
        targetHouse.userData.isFlashing = true;
        targetHouse.userData.flashInterval = setInterval(()=>{
          targetHouse.traverse(child => {
            if(child instanceof THREE.Mesh && !child.isLineSegments){
              child.material.color.set(child.material.color.getHex()===0xffa500?0xffffff:0xffa500);
            }
          });
        },200);
      }
    }
  }
  
  const startX = (Math.random()-0.5)*20;
  const startZ = (Math.random()-0.5)*20;
  const startY = 6 + Math.random()*4;
  let destY = startY;
  if(type === "red" && targetHouse){
    destY = startY;
  } else if(type === "white"){
    destY = 6 + Math.random()*4;
  }
  drone.position.set(startX,startY,startZ);
  
  let dir;
  let intermediateTarget = null;
  if(type === "red" && targetHouse){
    const intermediateX = (Math.random()-0.5)*20;
    const intermediateZ = (Math.random()-0.5)*20;
    intermediateTarget = new THREE.Vector3(intermediateX, startY, intermediateZ);
    dir = new THREE.Vector3().subVectors(intermediateTarget, drone.position).normalize();
  } else {
    const destX = (Math.random()-0.5)*20;
    const destZ = (Math.random()-0.5)*20;
    const destination = new THREE.Vector3(destX, destY, destZ);
    dir = new THREE.Vector3().subVectors(destination, drone.position).normalize();
  }

  const baseSpeed = type==="red" ? 0.015 + Math.random()*0.015 : 0.0025 + Math.random()*0.005;
  const diveSpeed = 0.015 + Math.random()*0.03;
  const diveBoostSpeed = diveSpeed * 1.5;

  const toolbar = document.createElement('div');
  toolbar.className = 'drone-toolbar';
  document.body.appendChild(toolbar);

  let trajectoryColor;
  if(type === "red") trajectoryColor = 0xff0000;
  else if(type === "white") trajectoryColor = 0xffffff;
  else if(type === "scout") trajectoryColor = 0x0000ff;
  const futureTrajectoryGeometry = new THREE.BufferGeometry();
  const futureTrajectoryMaterial = new THREE.LineDashedMaterial({
    color: trajectoryColor,
    linewidth: 1,
    scale: 1,
    dashSize: 0.2,
    gapSize: 0.2,
    transparent: true,
    opacity: 0.5
  });
  const futureTrajectoryLine = new THREE.Line(futureTrajectoryGeometry, futureTrajectoryMaterial);
  scene.add(futureTrajectoryLine);

  drone.userData = {
    target: targetHouse,
    intermediateTarget: intermediateTarget,
    direction: dir,
    speed: baseSpeed,
    baseSpeed,
    diveSpeed,
    diveBoostSpeed,
    hasAttacked: false,
    type,
    trail: [],
    diving: false,
    futureTrajectoryLine,
    toolbar,
    lastDirectionChange: Date.now(),
    destY: destY
  };
  scene.add(drone);
  drones.push(drone);
}

// === Scene Parameters ===
let targetRedDrones = 2;
let targetWhiteDrones = 3;
let targetScoutDrones = 1;
let missileInterval = 16000;
let cruiseMissileInterval = 10000;
let whiteDroneInterval = 3000;
let redDroneInterval = 10000;
let scoutDroneInterval = 8000;
let lastMissileTime = Date.now();
let lastCruiseMissileTime = Date.now();
let lastWhiteSpawn = Date.now();
let lastRedSpawn = Date.now();
let lastScoutSpawn = Date.now();

// Initialize drones
for(let i=0;i<targetWhiteDrones;i++){createDrone("white");}
for(let i=0;i<targetRedDrones;i++){createDrone("red");}
for(let i=0;i<targetScoutDrones;i++){createDrone("scout");}

// === Missile Target Marker (Ballistic) ===
const MARKER_DURATION = 5000; // 5 seconds
const INITIAL_MARKER_RADIUS = GRID_SIZE / 4; // 20 / 4 = 5.0
const FINAL_MARKER_RADIUS = 0.05; // Final tiny spot

const targetMarkerGeometry = new THREE.CircleGeometry(1, 64); // Base size 1
const targetMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.2, side: THREE.DoubleSide }); 
const targetMarker = new THREE.Mesh(targetMarkerGeometry, targetMarkerMaterial);
targetMarker.rotation.x = -Math.PI/2;
// –ü–æ–¥–Ω–∏–º–∞–µ–º –º–∞—Ä–∫–µ—Ä —á—É—Ç—å –≤—ã—à–µ —Å–µ—Ç–∫–∏ (Y=0.0) –∏ –¥–æ—Ä–æ–≥/—Ä–∞–¥–∞—Ä–∞ (Y=0.01)
targetMarker.position.y = 0.02; 
targetMarker.scale.set(0, 0, 0);
scene.add(targetMarker);
let markerTargetPos = new THREE.Vector3(0, 0, 0);
let markerStartTime = 0;
let markerActive = false;
let missileToTrack = null;

// === Missiles (Ballistic) ===
const BALLISTIC_MISSILE_SIZE = 0.5; 
const missiles = [];
function createMissile() {
  const missile = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.5, 12), new THREE.MeshBasicMaterial({color: 0xff0000}));
  const x = (Math.random() - 0.5) * 20;
  const z = (Math.random() - 0.5) * 20;
  const startY = 8 + Math.random()*2;
  missile.position.set(x, startY, z);
  
  const endX = (Math.random() - 0.5) * 20;
  const endZ = (Math.random() - 0.5) * 20;
  const destination = new THREE.Vector3(endX, 0, endZ);
  
  const speed = 0.2; 
  const timeFrames = startY / speed;
  const dx = (endX - x) / timeFrames;
  const dz = (endZ - z) / timeFrames;
  const fallTimeMs = timeFrames * (1000/60); // Total fall time in ms (at 60 FPS)
  
  missile.userData = {
    speed: speed, 
    trail: [], 
    type: "ballistic",
    targetPos: destination,
    fallTimeMs: fallTimeMs,
    startTime: Date.now(),
    dx: dx,
    dz: dz
  };
  scene.add(missile);
  missiles.push(missile);
  
  // Activate marker for this missile if none is active
  if(!markerActive){
      markerActive = true;
      missileToTrack = missile;
      markerTargetPos.copy(destination);
      targetMarker.position.set(markerTargetPos.x, 0.02, markerTargetPos.z); // –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è Y
      markerStartTime = Date.now();
      targetMarker.scale.setScalar(INITIAL_MARKER_RADIUS);
      targetMarker.material.opacity = 0.2;
  }
}

// === Cruise Missiles (–ö–†) - Color changed to white ===
const CRUISE_MISSILE_SIZE = 0.1; 
const cruiseMissiles = [];
function createCruiseMissile() {
  // –ö–† —Ç–µ–ø–µ—Ä—å –±–µ–ª–∞—è (0xffffff)
  const missile = new THREE.Mesh(new THREE.SphereGeometry(CRUISE_MISSILE_SIZE, 12, 12), new THREE.MeshBasicMaterial({color: 0xffffff}));
  
  let startX, startZ;
  const startEdge = Math.floor(Math.random() * 4);
  if (startEdge === 0) { startX = -10; startZ = (Math.random() - 0.5) * 20; }
  else if (startEdge === 1) { startX = 10; startZ = (Math.random() - 0.5) * 20; }
  else if (startEdge === 2) { startX = (Math.random() - 0.5) * 20; startZ = -10; }
  else { startX = (Math.random() - 0.5) * 20; startZ = 10; }
  
  const startY = 5 + Math.random() * 2;
  missile.position.set(startX, startY, startZ);

  const availableHouses = houses.filter(h => !h.userData.isHit);
  let targetHouse = null;
  if (availableHouses.length > 0) {
      targetHouse = availableHouses[Math.floor(Math.random() * availableHouses.length)];
  }

  const endPos = targetHouse ? targetHouse.position.clone() : new THREE.Vector3((Math.random()-0.5)*20, 0, (Math.random()-0.5)*20);
  endPos.y = 0;

  const control1 = new THREE.Vector3(
    startX + (endPos.x - startX) * 0.5,
    startY, 
    startZ + (endPos.z - startZ) * 0.5
  );
  
  const control2 = new THREE.Vector3(
    endPos.x + (Math.random() - 0.5) * 5,
    Math.max(endPos.y + 0.1, startY * 0.5), 
    endPos.z + (Math.random() - 0.5) * 5
  );

  const curve = new THREE.CubicBezierCurve3(missile.position.clone(), control1, control2, endPos);
  
  missile.userData = {
    type: "cruise",
    speed: 0.005,
    baseSpeed: 0.005,
    curve: curve,
    t: 0,
    trail: [],
    target: targetHouse
  };
  
  scene.add(missile);
  cruiseMissiles.push(missile);
}


// === Rockets (PVO) ===
const ROCKET_SIZE = 0.1;
const rockets = [];
function launchRocket(target){
  if(!target) return;
  const rocket = new THREE.Mesh(new THREE.SphereGeometry(ROCKET_SIZE,8,8), new THREE.MeshBasicMaterial({color:0xffff00}));
  rocket.position.copy(pvo.position);
  rocket.userData = {
    target,
    trail: [],
    initialDistance: rocket.position.distanceTo(target.position),
    launchTime: Date.now()
  };
  scene.add(rocket);
  rockets.push(rocket);
}

// === Score Update Function ===
const scoreCounter = document.getElementById('score-counter');
function updateScore(points = 1) {
    score += points;
    // –£–±–∏—Ä–∞–µ–º —Å–ª–æ–≤–æ "–°–±–∏—Ç–æ:"
    scoreCounter.textContent = `${score}`;
}

// === Explosion (Realistic) ===
function createExplosion(position, type="drone", sizeFactor=1){
  let initialRadius, maxRadius, blastRadius;
  
  if (type === "drone" || type === "rocket") {
    // 6 times the diameter (0.2 for drone, 0.2 for rocket)
    maxRadius = 0.6 * sizeFactor;
    blastRadius = 2.0;
  } else if (type === "missile") {
    // –ö–æ–ø–∏—Ä—É–µ–º –≤–∑—Ä—ã–≤ –¥—Ä–æ–Ω–∞, –Ω–æ –¥–∏–∞–º–µ—Ç—Ä –≤ 4 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ (—Ä–∞–¥–∏—É—Å –≤ 4 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ)
    maxRadius = 0.6 * 4;
    blastRadius = 2.0 * 4; // –¢–∞–∫–∂–µ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∑–æ–Ω—É –ø–æ—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
  } else {
    maxRadius = 0.5 * sizeFactor;
    blastRadius = 1.5;
  }

  initialRadius = 0.05; 
  
  const geometry = new THREE.SphereGeometry(1, 16, 16); 
  
  // –≠—Ñ—Ñ–µ–∫—Ç —è—Ä–∫–æ–π –≤—Å–ø—ã—à–∫–∏ (Hot Core)
  const flash = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color:0xffaa00, transparent:true, opacity:0.9}));
  flash.position.copy(position);
  if(position.y < 0.2) flash.position.y = 0.01;
  scene.add(flash);
  
  // –≠—Ñ—Ñ–µ–∫—Ç –¥—ã–º–∞/–æ—Å—Ç—ã–≤–∞—é—â–µ–≥–æ –ø–ª–∞–º–µ–Ω–∏ (Smoke/Afterglow)
  const smoke = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color:0xaa0000, transparent:true, opacity:0.05})); 
  smoke.position.copy(position);
  if(position.y < 0.2) smoke.position.y = 0.01;
  scene.add(smoke);

  const duration = type === "missile" ? 60 : 40; // 3 seconds vs 2 seconds
  let frame = 0;

  const interval = setInterval(()=>{
    frame++;
    const progress = frame / duration;

    // Phase 1: Rapid expansion and peak (0% to 50% progress)
    if(progress <= 0.5){
        const phaseProgress = progress * 2; // 0 to 1
        
        // Flash: quick expansion, quick decay
        const flashScale = initialRadius + (maxRadius * 0.5 - initialRadius) * phaseProgress;
        flash.scale.setScalar(flashScale);
        flash.material.opacity = 0.9 - 0.9 * phaseProgress; // Rapid fade
        
        // Smoke: expansion and gradual increase in opacity
        const smokeScale = initialRadius + (maxRadius * 0.9 - initialRadius) * phaseProgress; 
        smoke.scale.setScalar(smokeScale);
        smoke.material.opacity = 0.05 + (0.5 - 0.05) * phaseProgress; // Gradual density
    }
    // Phase 2: Smoke reaches max size and dissipates (50% to 100% progress)
    else if(progress > 0.5 && progress <= 1){
        const phaseProgress = (progress - 0.5) * 2; // 0 to 1
        
        // Flash: ensure it's gone
        flash.material.opacity = 0; 

        // Smoke: reaches max scale and fades to zero
        const smokeScale = maxRadius * 0.9 + (maxRadius - maxRadius * 0.9) * phaseProgress; 
        smoke.scale.setScalar(smokeScale);
        smoke.material.opacity = 0.5 - 0.5 * phaseProgress; // Fade to zero at max diameter
    }
    // Phase 3: Cleanup ( > 100% progress)
    else {
        flash.material.opacity = 0;
        smoke.material.opacity = 0; 
    }

    if(progress >= 1){
      scene.remove(flash);
      scene.remove(smoke);
      
      try{
        flash.geometry.dispose();
        flash.material.dispose();
        smoke.geometry.dispose();
        smoke.material.dispose();
      }catch(e){/*ignore*/}
      clearInterval(interval);
    }
  },50); // 20 FPS animation
  
  if (type !== "rocket") {
    applyBlastDamage(position, blastRadius, type==="missile");
  }
}

// === Marker functions ===
function createHouseMarker(house, isMissileHit = false){
  if(!house || house.userData.isHit) return;
  if(house.userData.flashInterval){
    clearInterval(house.userData.flashInterval);
    house.userData.flashInterval = null;
    house.userData.isFlashing = false;
  }
  house.traverse(child => {
    if(child instanceof THREE.Mesh && !child.isLineSegments){
      child.material.opacity = 0;
      child.material.transparent = true;
      const geometry = new THREE.EdgesGeometry(child.geometry);
      const material = isMissileHit ? new THREE.LineDashedMaterial({
        color: 0xffa500,
        linewidth: 1,
        scale: 2,
        dashSize: 0.2,
        gapSize: 0.2
      }) : new THREE.LineBasicMaterial({color: 0xffa500});
      const line = new THREE.LineSegments(geometry, material);
      if(isMissileHit && line.computeLineDistances) line.computeLineDistances();
      line.position.copy(child.position);
      house.add(line);
    }
  });
  house.userData.isHit = true;
}

function createCarMarker(car, isMissileHit = false){
  if(!car || car.userData.isHit) return;
  car.userData.isHit = true;
  car.userData.baseSpeed = 0;
  car.userData.speed = 0;

  if(car.userData.flashInterval){
    clearInterval(car.userData.flashInterval);
    car.userData.flashInterval = null;
    car.userData.isFlashing = false;
  }

  if(car.material){
    car.material.opacity = 0;
    car.material.transparent = true;
  }
  const geometry = new THREE.EdgesGeometry(car.geometry);
  const material = isMissileHit ? new THREE.LineDashedMaterial({
    color: 0xffa500,
    linewidth: 1,
    scale: 2,
    dashSize: 0.2,
    gapSize: 0.2
  }) : new THREE.LineBasicMaterial({color: 0xffa500});
  const line = new THREE.LineSegments(geometry, material);
  if(isMissileHit && line.computeLineDistances) line.computeLineDistances();
  line.position.copy(car.position);
  line.rotation.copy(car.rotation);
  scene.add(line);
  car.userData.marker = line;
}

function createPersonMarker(person, isMissileHit = false){
  if(!person || person.userData.isHit) return;
  person.userData.isHit = true;
  person.userData.baseSpeed = 0;
  person.userData.speed = 0;

  if(person.userData.flashInterval){
    clearInterval(person.userData.flashInterval);
    person.userData.flashInterval = null;
    person.userData.isFlashing = false;
  }

  if(person.material){
    person.material.opacity = 0;
    person.material.transparent = true;
  }
  const geometry = new THREE.EdgesGeometry(person.geometry);
  const material = isMissileHit ? new THREE.LineDashedMaterial({
    color: 0xffa500,
    linewidth: 1,
    scale: 2,
    dashSize: 0.2,
    gapSize: 0.2
  }) : new THREE.LineBasicMaterial({color: 0xffa500});
  const line = new THREE.LineSegments(geometry, material);
  if(isMissileHit && line.computeLineDistances) line.computeLineDistances();
  line.position.copy(person.position);
  line.rotation.copy(person.rotation);
  scene.add(line);
  person.userData.marker = line;
}

// === Trail helper (–ö–† —Ç–µ–ø–µ—Ä—å –∏–º–µ–µ—Ç –∫—Ä–∞—Å–Ω—ã–π —Å–ª–µ–¥) ===
function addTrail(object, isMissile=false, isRocket=false, isCruise=false){
  const isScout = !isMissile && !isRocket && !isCruise && object.userData.type === "scout";
  const isDivingRed = !isMissile && !isRocket && !isCruise && object.userData.type === "red" && object.userData.diving;
  const trailGeo = new THREE.SphereGeometry(isScout ? 0.1 : (isRocket ? 0.1 : 0.08), 8, 8);
  
  // –°–ª–µ–¥ –ö–† —Ç–µ–ø–µ—Ä—å –∫—Ä–∞—Å–Ω—ã–π, –∫–∞–∫ —É –±–∞–ª–ª–∏—Å—Ç–∏—á–µ—Å–∫–æ–π
  const trailColor = isRocket ? 0xffff00 : 0xff0000; 
  
  const trailMat = new THREE.MeshBasicMaterial({
    color: trailColor,
    transparent: true,
    opacity: isRocket ? 0.6 : 0.8
  });
  const particle = new THREE.Mesh(trailGeo, trailMat);
  particle.position.copy(object.position);
  scene.add(particle);
  const trailLife = isDivingRed ? 80 : (isScout ? 50 : (isRocket ? 60 : 30));
  object.userData.trail.push({mesh: particle, life: trailLife});
  trails.push(object.userData.trail[object.userData.trail.length-1]);
}

// === Traffic ===
const cars = [];
function spawnCars(numPerRoad = 6){
  roads.forEach(road=>{
    const isHorizontal = road.w > road.h;
    for(let i=0;i<numPerRoad;i++){
      const car = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.4), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.5}));
      const speed = 0.01 + Math.random()*0.02;
      if(isHorizontal){
        const startX = road.x - road.w/2 + Math.random()*road.w;
        car.position.set(startX,0.1,road.z);
        car.userData = {speed, baseSpeed: speed, isHorizontal:true, road, isHit: false, flashInterval: null, isFlashing: false};
      } else {
        const startZ = road.z - road.h/2 + Math.random()*road.h;
        car.position.set(road.x,0.1,startZ);
        car.userData = {speed, baseSpeed: speed, isHorizontal:false, road, isHit: false, flashInterval: null, isFlashing: false};
      }
      scene.add(car);
      cars.push(car);
    }
  });
}
spawnCars();

function spawnSingleCar(road){
  const isHorizontal = road.w > road.h;
  const car = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.4), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.5}));
  const speed = 0.01 + Math.random()*0.02;
  if(isHorizontal){
    const startX = road.x - road.w/2 + Math.random()*road.w;
    car.position.set(startX,0.1,road.z);
    car.userData = {speed, baseSpeed: speed, isHorizontal:true, road, isHit: false, flashInterval: null, isFlashing: false};
  } else {
    const startZ = road.z - road.h/2 + Math.random()*road.h;
    car.position.set(road.x,0.1,startZ);
    car.userData = {speed, baseSpeed: speed, isHorizontal:false, road, isHit: false, flashInterval: null, isFlashing: false};
  }
  scene.add(car);
  cars.push(car);
  return car;
}

const people = [];
function spawnPeople(numPerRoad = 8){
  roads.forEach(road=>{
    const isHorizontal = road.w > road.h;
    for(let i=0;i<numPerRoad;i++){
      const person = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.1,0.2), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.5}));
      const baseSpeed = (0.01 + Math.random()*0.02) / 16;
      let startX, startZ, endX, endZ;
      if(isHorizontal){
        startX = road.x - road.w/2 + Math.random()*road.w;
        startZ = road.z;
        endX = road.x - road.w/2 + Math.random()*road.w;
        endZ = road.z;
      } else {
        startX = road.x;
        startZ = road.z - road.h/2 + Math.random()*road.h;
        endX = road.x;
        endZ = road.z - road.h/2 + Math.random()*road.h;
      }
      person.position.set(startX,0.05,startZ);
      const startPos = person.position.clone();
      const endPos = new THREE.Vector3(endX, 0.05, endZ);
      const control1 = new THREE.Vector3(
        startPos.x + (Math.random() - 0.5) * (isHorizontal ? road.w : road.h) * 0.5,
        0.05,
        startPos.z + (Math.random() - 0.5) * (isHorizontal ? road.w : road.h) * 0.5
      );
      const control2 = new THREE.Vector3(
        endX + (Math.random() - 0.5) * (isHorizontal ? road.w : road.h) * 0.5,
        0.05,
        endZ + (Math.random() - 0.5) * (isHorizontal ? road.w : road.h) * 0.5
      );
      const curve = new THREE.CubicBezierCurve3(startPos, control1, control2, endPos);
      person.userData = {
        speed: baseSpeed,
        baseSpeed,
        isHorizontal,
        road,
        isHit: false,
        flashInterval: null,
        isFlashing: false,
        curve,
        t: 0
      };
      scene.add(person);
      people.push(person);
    }
  });
}
spawnPeople();

function spawnSinglePerson(road){
  const isHorizontal = road.w > road.h;
  const person = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.1,0.2), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.5}));
  const baseSpeed = (0.01 + Math.random()*0.02) / 16;
  let startX, startZ, endX, endZ;
  if(isHorizontal){
    startX = road.x - road.w/2 + Math.random()*road.w;
    startZ = road.z;
    endX = road.x - road.w/2 + Math.random()*road.w;
    endZ = road.z;
  } else {
    startX = road.x;
    startZ = road.z - road.h/2 + Math.random()*road.h;
    endX = road.x;
    endZ = road.z - road.h/2 + Math.random()*road.h;
  }
  person.position.set(startX,0.05,startZ);
  const startPos = person.position.clone();
  const endPos = new THREE.Vector3(endX, 0.05, endZ);
  const control1 = new THREE.Vector3(
    startPos.x + (Math.random() - 0.5) * (isHorizontal ? road.w : road.h) * 0.5,
    0.05,
    startPos.z + (Math.random() - 0.5) * (isHorizontal ? road.w : road.h) * 0.5
  );
  const control2 = new THREE.Vector3(
    endX + (Math.random() - 0.5) * (isHorizontal ? road.w : road.h) * 0.5,
    0.05,
    endZ + (Math.random() - 0.5) * (isHorizontal ? road.w : road.h) * 0.5
  );
  const curve = new THREE.CubicBezierCurve3(startPos, control1, control2, endPos);
  person.userData = {
    speed: baseSpeed,
    baseSpeed,
    isHorizontal,
    road,
    isHit: false,
    flashInterval: null,
    isFlashing: false,
    curve,
    t: 0
  };
  scene.add(person);
  people.push(person);
  return person;
}

function updateCars(){
  const safeDistance = 1.0;
  const accel = 0.0005;
  const brake = 0.001;

  for(const car of cars){
    const data = car.userData;
    if(data.isHit) continue;

    let nearestDist = Infinity;

    for(const other of cars){
      if(other === car) continue;
      if(other.userData.isHit) continue;
      const oData = other.userData;
      if(oData.isHorizontal !== data.isHorizontal) continue;
      if(oData.road !== data.road) continue;

      if(data.isHorizontal){
        if(other.position.x > car.position.x){
          const dist = other.position.x - car.position.x;
          if(dist < nearestDist) nearestDist = dist;
        }
      } else {
        if(other.position.z > car.position.z){
          const dist = other.position.z - car.position.z;
          if(dist < nearestDist) nearestDist = dist;
        }
      }
    }

    if(nearestDist < safeDistance){
      data.speed = Math.max(0, data.speed - brake);
    } else if(data.speed < data.baseSpeed){
      data.speed = Math.min(data.baseSpeed, data.speed + accel);
    }

    if(data.isHorizontal){
      car.position.x += data.speed;
      if(car.position.x > data.road.x + data.road.w / 2) car.position.x = data.road.x - data.road.w / 2;
    } else {
      car.position.z += data.speed;
      if(car.position.z > data.road.z + data.road.h / 2) car.position.z = data.road.z - data.road.h / 2;
    }
  }
}

function updatePeople(){
  const safeDistance = 0.5;
  const accel = 0.0000625;
  const brake = 0.000125;

  for(const person of people){
    const data = person.userData;
    if(data.isHit) continue;

    let nearestDist = Infinity;

    for(const other of people){
      if(other === person) continue;
      const oData = other.userData;
      if(oData.isHorizontal !== data.isHorizontal) continue;
      if(oData.road !== data.road) continue;

      if(data.isHorizontal){
        if(other.position.x > person.position.x){
          const dist = other.position.x - person.position.x;
          if(dist < nearestDist) nearestDist = dist;
        }
      } else {
        if(other.position.z > person.position.z){
          const dist = other.position.z - person.position.z;
          if(dist < nearestDist) nearestDist = dist;
        }
      }
    }

    if(nearestDist < safeDistance){
      data.speed = Math.max(0, data.speed - brake);
    } else if(data.speed < data.baseSpeed){
      data.speed = Math.min(data.baseSpeed, data.speed + accel);
    }

    if(data.t < 1){
      data.t = Math.min(data.t + data.speed, 1);
      person.position.copy(data.curve.getPoint(data.t));
    } else {
      const startPos = person.position.clone();
      const endX = data.isHorizontal ? data.road.x - data.road.w/2 + Math.random()*data.road.w : data.road.x;
      const endZ = data.isHorizontal ? data.road.z : data.road.z - data.road.h/2 + Math.random()*data.road.h;
      const endPos = new THREE.Vector3(endX, 0.05, endZ);
      const control1 = new THREE.Vector3(
        startPos.x + (Math.random() - 0.5) * (data.isHorizontal ? data.road.w : data.road.h) * 0.5,
        0.05,
        startPos.z + (Math.random() - 0.5) * (data.isHorizontal ? data.road.w : data.road.h) * 0.5
      );
      const control2 = new THREE.Vector3(
        endX + (Math.random() - 0.5) * (data.isHorizontal ? data.road.w : data.road.h) * 0.5,
        0.05,
        endZ + (Math.random() - 0.5) * (data.isHorizontal ? data.road.w : data.road.h) * 0.5
      );
      const curve = new THREE.CubicBezierCurve3(startPos, control1, control2, endPos);
      data.curve = curve;
      data.t = 0;
    }
  }
}

// === Unified blast damage ===
function applyBlastDamage(center, blastRadius = 3, isMissile = false){
  for(let j = houses.length - 1; j >= 0; j--){
    const house = houses[j];
    if(house.userData.isHit) continue;
    const dist = Math.sqrt((house.position.x - center.x)**2 + (house.position.z - center.z)**2);
    if(dist < blastRadius){
      createHouseMarker(house, isMissile);
    }
  }
  for(let j = cars.length - 1; j >= 0; j--){
    const car = cars[j];
    if(car.userData.isHit) continue;
    const dist = Math.sqrt((car.position.x - center.x)**2 + (car.position.z - center.z)**2);
    if(dist < blastRadius){
      createCarMarker(car, isMissile);
      spawnSingleCar(car.userData.road);
    }
  }
  for(let j = people.length - 1; j >= 0; j--){
    const person = people[j];
    if(person.userData.isHit) continue;
    const dist = Math.sqrt((person.position.x - center.x)**2 + (person.position.z - center.z)**2);
    if(dist < blastRadius){
      createPersonMarker(person, isMissile);
      spawnSinglePerson(person.userData.road);
    }
  }
}

// === Controls ===
let isDragging = false;
let isPotentialDrag = false;
let startX = 0;
let startY = 0;
let previousMousePosition = {x:0,y:0};
function rotateScene(deltaX,deltaY){
  camAzim -= deltaX; 
  camPolar += deltaY;
  if(camPolar<0.1) camPolar = 0.1;
  if(camPolar>Math.PI/2) camPolar = Math.PI/2;
  camera.position.x = camRadius * Math.sin(camPolar) * Math.sin(camAzim);
  camera.position.y = camRadius * Math.cos(camPolar);
  camera.position.z = camRadius * Math.sin(camPolar) * Math.cos(camAzim);
  camera.lookAt(0,0,0);
}
function onPointerDown(event){
  if(event.touches && event.touches.length === 1){
    isPotentialDrag = true;
    startX = event.touches[0].clientX;
    startY = event.touches[0].clientY;
    previousMousePosition.x = startX;
    previousMousePosition.y = startY;
  } else {
    if(event.button === 0){
      isDragging = true;
      previousMousePosition.x = event.clientX;
      previousMousePosition.y = event.clientY;
    } else if(event.button === 2){ 
      const threats = [...drones, ...missiles, ...cruiseMissiles];
      if(threats.length > 0){
        let target = threats[Math.floor(Math.random() * threats.length)];
        launchRocket(target);
      }
    }
  }
}
function onPointerMove(event){
  let clientX, clientY;
  if(event.touches && event.touches.length === 1){
    clientX = event.touches[0].clientX;
    clientY = event.touches[0].clientY;
  } else {
    clientX = event.clientX;
    clientY = event.clientY;
  }
  const deltaX = Math.abs(clientX - startX);
  const deltaY = Math.abs(clientY - startY);
  if(isPotentialDrag && (deltaX > 10 || deltaY > 10)){
    isDragging = true;
    isPotentialDrag = false;
  }
  if(isDragging){
    rotateScene((clientX - previousMousePosition.x) * 0.01, (clientY - previousMousePosition.y) * 0.01);
    previousMousePosition.x = clientX;
    previousMousePosition.y = clientY;
  }
}
function onPointerUp(event){
  if(isPotentialDrag){
    const threats = [...drones, ...missiles, ...cruiseMissiles];
    if(threats.length > 0){
      let target = threats[Math.floor(Math.random() * threats.length)];
      launchRocket(target);
    }
  }
  isPotentialDrag = false;
  isDragging = false;
}
document.addEventListener("mousedown",onPointerDown);
document.addEventListener("mousemove",onPointerMove);
document.addEventListener("mouseup",onPointerUp);
document.addEventListener("touchstart",onPointerDown);
document.addEventListener("touchmove",onPointerMove);
document.addEventListener("touchend",onPointerUp);
document.addEventListener("contextmenu",(e)=>e.preventDefault());

// === Animate ===
function animate(){
  requestAnimationFrame(animate);
  
  // Traffic
  updateCars();
  updatePeople();
  animateRadar();

  // Spawn threats
  if(Date.now() - lastMissileTime > missileInterval){
    createMissile();
    lastMissileTime = Date.now();
  }
  if(Date.now() - lastCruiseMissileTime > cruiseMissileInterval){
    createCruiseMissile();
    lastCruiseMissileTime = Date.now();
  }

  // Update Drone Toolbars
  for(const drone of drones){
    const altitude = Math.round(drone.position.y * 100);
    drone.userData.toolbar.textContent = `${altitude}m`;
    
    const vector = drone.position.clone().project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
    
    drone.userData.toolbar.style.left = `${x}px`;
    drone.userData.toolbar.style.top = `${y - 20}px`;
  }

  // Drones
  for(let i=drones.length-1;i>=0;i--){
    const drone = drones[i];
    const data = drone.userData;

    if(data.type === "scout" && Date.now() - data.lastDirectionChange > 2000){
      const destX = (Math.random()-0.5)*20;
      const destZ = (Math.random()-0.5)*20;
      data.destY = 6 + Math.random()*4;
      const destination = new THREE.Vector3(destX, data.destY, destZ);
      data.direction = new THREE.Vector3().subVectors(destination, drone.position).normalize();
      data.lastDirectionChange = Date.now();
    }

    if(data.type === "red" && data.target){
      const distXZ = Math.sqrt((drone.position.x - data.target.position.x)**2 + (drone.position.z - data.target.position.z)**2);
      if(distXZ > 8 && !data.diving){
        data.direction = new THREE.Vector3().subVectors(data.intermediateTarget, drone.position).normalize();
        if(data.intermediateTarget && drone.position.distanceTo(data.intermediateTarget) < 1){
          data.intermediateTarget = null;
          data.diving = true;
          data.direction = new THREE.Vector3().subVectors(data.target.position, drone.position).normalize();
        }
      } else if(distXZ <= 8 && distXZ > 5){
        data.diving = true;
        data.speed = data.diveSpeed;
        const targetPos = data.target.position.clone();
        targetPos.y = Math.max(drone.position.y - 1, 0);
        data.direction = new THREE.Vector3().subVectors(targetPos, drone.position).normalize();
      } else if(distXZ <= 5){
        data.speed = drone.position.y <= 4 ? data.diveBoostSpeed : data.diveSpeed;
        const targetPos = data.target.position.clone();
        targetPos.y = 0;
        data.direction = new THREE.Vector3().subVectors(targetPos, drone.position).normalize();
      }
    }

    const futureSteps = data.type === "white" ? 60 : 50;
    const futurePoints = [];
    let currentPos = drone.position.clone();
    const stepDistance = data.speed * 20;
    const gridBoundary = 10;
    for(let j=0; j<futureSteps; j++){
      let nextPos = currentPos.clone().add(data.direction.clone().multiplyScalar(stepDistance));
      if(Math.abs(nextPos.x) > gridBoundary || Math.abs(nextPos.z) > gridBoundary || nextPos.y < 0) break;
      futurePoints.push(nextPos);
      currentPos = nextPos;
    }
    const futurePositions = new Float32Array(futurePoints.length * 3);
    for(let j=0; j<futurePoints.length; j++){
      futurePositions[j*3] = futurePoints[j].x;
      futurePositions[j*3+1] = futurePoints[j].y;
      futurePositions[j*3+2] = futurePoints[j].z;
    }
    if(data.futureTrajectoryLine && data.futureTrajectoryLine.geometry){
      data.futureTrajectoryLine.geometry.setAttribute('position', new THREE.BufferAttribute(futurePositions, 3));
      if(data.futureTrajectoryLine.computeLineDistances) data.futureTrajectoryLine.computeLineDistances();
    }
    
    if(data.target && houses.includes(data.target)){
      const targetPos = data.target.position.clone();
      if(drone.position.distanceTo(targetPos)<5 && !data.hasAttacked){
        data.hasAttacked = true;
        data.speed = data.diveBoostSpeed;
        targetPos.y = 0;
      }
      drone.position.add(data.direction.clone().multiplyScalar(data.speed));
      
      if(drone.position.distanceTo(targetPos)<0.1){
        createExplosion(targetPos, "drone");

        if(!data.target.userData.isHit){
          createHouseMarker(data.target, false);
        }
        scene.remove(drone);
        if(data.toolbar && document.body.contains(data.toolbar)) document.body.removeChild(data.toolbar);
        if(data.futureTrajectoryLine){
          scene.remove(data.futureTrajectoryLine);
          try{ data.futureTrajectoryLine.geometry.dispose(); data.futureTrajectoryLine.material.dispose(); }catch(e){}
        }
        if(data.target.userData.flashInterval){
          clearInterval(data.target.userData.flashInterval);
          data.target.userData.flashInterval = null;
          data.target.traverse(child => {
            if(child instanceof THREE.Mesh && !child.isLineSegments){
              child.material.color.set(0xffffff);
            }
          });
        }
        drones.splice(i,1);
      }
    } else {
      drone.position.add(data.direction.clone().multiplyScalar(data.speed));
      if(drone.position.y <= 0 || Math.abs(drone.position.x)>16 || Math.abs(drone.position.z)>16){
        createExplosion(new THREE.Vector3(drone.position.x, Math.max(drone.position.y,0), drone.position.z), "drone", 0.5); 

        scene.remove(drone);
        if(data.toolbar && document.body.contains(data.toolbar)) document.body.removeChild(drone.userData.toolbar);
        if(data.futureTrajectoryLine){
          scene.remove(drone.userData.futureTrajectoryLine);
          try{ drone.userData.futureTrajectoryLine.geometry.dispose(); drone.userData.futureTrajectoryLine.material.dispose(); }catch(e){}
        }
        drones.splice(i,1);
      }
    }
  }

  // Ballistic Missiles
  for(let i = missiles.length - 1; i >= 0; i--){
    const missile = missiles[i];
    const data = missile.userData;
    
    const timeElapsed = Date.now() - data.startTime;
    const timeRemaining = data.fallTimeMs - timeElapsed;

    // –ê–∫—Ç–∏–≤–∞—Ü–∏—è –º–∞—Ä–∫–µ—Ä–∞ –∑–∞ 5 —Å–µ–∫—É–Ω–¥ (5000 –º—Å) –¥–æ —É–¥–∞—Ä–∞
    if(missile === missileToTrack && timeRemaining <= MARKER_DURATION && markerActive){
        const progress = 1 - (timeRemaining / MARKER_DURATION); // 0 at start, 1 at impact
        
        // –ú–∞—Å—à—Ç–∞–±: –æ—Ç INITIAL_MARKER_RADIUS –¥–æ FINAL_MARKER_RADIUS
        const scale = INITIAL_MARKER_RADIUS + (FINAL_MARKER_RADIUS - INITIAL_MARKER_RADIUS) * progress;
        targetMarker.scale.setScalar(scale);

        // –û–ø–∞—Å–∏—Ç–∏: –æ—Ç 0.2 –¥–æ 0.8 –∏ –∑–∞—Ç–µ–º –¥–æ 0
        let opacity;
        if (progress < 0.8) {
            opacity = 0.2 + (0.8 - 0.2) * (progress / 0.8);
        } else {
            opacity = 0.8 * (1 - (progress - 0.8) / 0.2); // Fade out quickly in last 20%
        }
        targetMarker.material.opacity = Math.max(0, opacity);
    }
    
    missile.position.x += data.dx;
    missile.position.z += data.dz;
    missile.position.y -= missile.userData.speed;
    addTrail(missile, true, false, false);
    
    if(missile.position.y <= 0){
      const explosionPos = missile.position.clone();
      explosionPos.y = 0;
      createExplosion(explosionPos, "missile");

      // –°–±—Ä–æ—Å –º–∞—Ä–∫–µ—Ä–∞
      if(missile === missileToTrack){
        targetMarker.scale.set(0, 0, 0);
        markerActive = false;
        missileToTrack = null;
      }

      scene.remove(missile);
      try{ missile.geometry.dispose(); missile.material.dispose(); }catch(e){}
      missiles.splice(i, 1);
    }
  }
  
  // Cruise Missiles (–ö–†)
  for(let i = cruiseMissiles.length - 1; i >= 0; i--){
    const missile = cruiseMissiles[i];
    const data = missile.userData;

    if (data.t < 1) {
      data.t = Math.min(data.t + data.speed, 1);
      const newPos = data.curve.getPoint(data.t);
      missile.position.copy(newPos);
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º trail –¥–ª—è –∫—Ä—ã–ª–∞—Ç—ã—Ö —Ä–∞–∫–µ—Ç (isCruise=true)
      addTrail(missile, false, false, true); 
      
    } else {
      createExplosion(missile.position, "missile");

      if(data.target && houses.includes(data.target)){
          createHouseMarker(data.target, true);
      }
      
      scene.remove(missile);
      try{ missile.geometry.dispose(); missile.material.dispose(); }catch(e){}
      cruiseMissiles.splice(i, 1);
    }
  }

  // Update trails (still needed for missiles and rockets)
  for(let i=trails.length-1;i>=0;i--){
    const trail = trails[i];
    trail.mesh.material.opacity -= 0.03;
    if(trail.mesh.material.opacity <= 0){
      scene.remove(trail.mesh);
      try{
        trail.mesh.geometry.dispose();
        trail.mesh.material.dispose();
      }catch(e){/*ignore*/}
      trails.splice(i,1);
    }
  }

  // Maintain drone counts
  let whiteCount = drones.filter(d=>d.userData.type==="white").length;
  let redCount = drones.filter(d=>d.userData.type==="red").length;
  let currentScoutCount = drones.filter(d=>d.userData.type==="scout").length;
  
  if(whiteCount < targetWhiteDrones && Date.now() - lastWhiteSpawn > whiteDroneInterval){
    createDrone("white");
    lastWhiteSpawn = Date.now();
  }
  if(redCount < targetRedDrones && Date.now() - lastRedSpawn > redDroneInterval){
    createDrone("red");
    lastRedSpawn = Date.now();
  }
  if(currentScoutCount < targetScoutDrones && Date.now() - lastScoutSpawn > scoutDroneInterval){
    createDrone("scout");
    lastScoutSpawn = Date.now();
  }
  
  while(whiteCount > targetWhiteDrones){
    const drone = drones.find(d=>d.userData.type==="white");
    if(drone){
      scene.remove(drone);
      if(drone.userData.toolbar && document.body.contains(drone.userData.toolbar)) document.body.removeChild(drone.userData.toolbar);
      if(drone.userData.futureTrajectoryLine){
        scene.remove(drone.userData.futureTrajectoryLine);
        try{ drone.userData.futureTrajectoryLine.geometry.dispose(); drone.userData.futureTrajectoryLine.material.dispose(); }catch(e){}
      }
      drones.splice(drones.indexOf(drone),1);
      whiteCount--;
    }
  }
  while(redCount > targetRedDrones){
    const drone = drones.find(d=>d.userData.type==="red");
    if(drone){
      scene.remove(drone);
      if(drone.userData.toolbar && document.body.contains(drone.userData.toolbar)) document.body.removeChild(drone.userData.toolbar);
      if(drone.userData.futureTrajectoryLine){
        scene.remove(drone.userData.futureTrajectoryLine);
        try{ drone.userData.futureTrajectoryLine.geometry.dispose(); drone.userData.futureTrajectoryLine.material.dispose(); }catch(e){}
      }
      drones.splice(drones.indexOf(drone),1);
      redCount--;
    }
  }
  while(currentScoutCount > targetScoutDrones){
    const drone = drones.find(d=>d.userData.type==="scout");
    if(drone){
      scene.remove(drone);
      if(drone.userData.toolbar && document.body.contains(drone.userData.toolbar)) document.body.removeChild(drone.userData.toolbar);
      if(drone.userData.futureTrajectoryLine){
        scene.remove(drone.userData.futureTrajectoryLine);
        try{ drone.userData.futureTrajectoryLine.geometry.dispose(); drone.userData.futureTrajectoryLine.material.dispose(); }catch(e){}
      }
      drones.splice(drones.indexOf(drone),1);
      currentScoutCount--;
    }
  }
  
  // Rockets
  for(let i=rockets.length-1;i>=0;i--){
    const rocket = rockets[i];
    const target = rocket.userData.target;
    
    if(!target || (!drones.includes(target) && !missiles.includes(target) && !cruiseMissiles.includes(target))){
      scene.remove(rocket);
      try{ rocket.geometry.dispose(); rocket.material.dispose(); }catch(e){}
      rockets.splice(i,1);
      continue;
    }
    
    const distanceToTarget = rocket.position.distanceTo(target.position);
    const remainingFraction = distanceToTarget / rocket.userData.initialDistance;
    
    let speed;
    if(remainingFraction > 0.8) {
      speed = 0.1;
    } else if(remainingFraction > 0.2) {
      speed = 1.0;
    } else {
      speed = 0.20;
    }

    const dir = target.position.clone().sub(rocket.position).normalize();
    rocket.position.add(dir.multiplyScalar(speed));
    
    addTrail(rocket, false, true, false);

    if(distanceToTarget < 0.1){
      createExplosion(rocket.position, "rocket");
      
      scene.remove(rocket);
      try{ rocket.geometry.dispose(); rocket.material.dispose(); }catch(e){}
      rockets.splice(i,1);
      
      // Target destruction logic and score update
      if(missiles.includes(target)){
        if(target === missileToTrack){
            targetMarker.scale.set(0, 0, 0);
            markerActive = false;
            missileToTrack = null;
        }
        scene.remove(target);
        try{ target.geometry.dispose(); target.material.dispose(); }catch(e){}
        missiles.splice(missiles.indexOf(target),1);
        updateScore(1);
      } else if(cruiseMissiles.includes(target)){
        scene.remove(target);
        try{ target.geometry.dispose(); target.material.dispose(); }catch(e){}
        cruiseMissiles.splice(cruiseMissiles.indexOf(target),1);
        updateScore(1);
      } else if(drones.includes(target)){
        scene.remove(target);
        if(target.userData.toolbar && document.body.contains(target.userData.toolbar)) document.body.removeChild(target.userData.toolbar);
        if(target.userData.futureTrajectoryLine){
          scene.remove(target.userData.futureTrajectoryLine);
          try{ target.userData.futureTrajectoryLine.geometry.dispose(); target.userData.futureTrajectoryLine.material.dispose(); }catch(e){}
        }
        drones.splice(drones.indexOf(target),1);
        updateScore(1);
      }
    }
    if(Math.abs(rocket.position.x)>999||Math.abs(rocket.position.z)>999){
      scene.remove(rocket);
      try{ rocket.geometry.dispose(); rocket.material.dispose(); }catch(e){}
      rockets.splice(i,1);
    }
  }

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>